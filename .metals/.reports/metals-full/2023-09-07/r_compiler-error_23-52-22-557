java.lang.AssertionError: assertion failed
occurred in the presentation compiler.

action parameters:
offset: 1319
uri: file://<WORKSPACE>/src/main/scala/co.blocke.scala_reflection/RType.scala
text:
package co.blocke.scala_reflection

import scala.quoted.*
// import Liftables.*

trait RType[R]:
  type T = R                // R is saved for accessibility during casting, ie myRType.asInstanceOf[fooRType.T]
  val name: String          // fully-qualified class name of this type
  def toType(quotes: Quotes): quoted.Type[R] = quotes.reflect.TypeRepr.typeConstructorOf(Class.forName(name)).asType.asInstanceOf[Type[R]]
//   def show(
//     tab: Int = 0,
//     seenBefore: List[String] = Nil,
//     suppressIndent: Boolean = false,
//     modified: Boolean = false // modified is "special", ie. don't show index & sort for nonconstructor fields
//   ): String = infoClass.getClass.getName
//   override def toString(): String = show()

/** This RType mixin needed because j
 * ust because something is an AppliedType doesn't mean it has parameters.  
 *  For examlpe a case class could be an applied type (isAppliedType=true) or not.  A collection is always applied.
 */
trait AppliedRType[R]:
  self: RType[R] =>
  def isAppliedType: Boolean = true  // can be overridden to false, e.g. Scala class that isn't parameterized
  // Take a parameterized type's normal type 'T' and map it to the declared type 'X'
  def resolveTypeParams( paramMap: Map[TypeSymbol, RType[_]] ): RType[R]

trait PrimitiveRType[R]:
  self: R@@


// Poked this here for now.  Used for show()
final inline def tabs(t:Int) = "   "*t

case class ClassRType[T](name: String, infoClass: Class[T]) extends RType[T]


object RType:

  //------------------------
  //  <<  MACRO ENTRY >>
  //------------------------
  inline def of[T]: RType[T] = ${ ofImpl[T]() }

  def ofImpl[T]()(using quotes: Quotes, ttype: scala.quoted.Type[T]): Expr[RType[T]] =
    import quotes.reflect.*

    // '{ StringRType().asInstanceOf[RType[T]] }  //<-- This Works

    // val result = StringRType().asInstanceOf[RType[T]] 
    // Expr(result)  // <-- This doesn't

    val a = Expr("co.blocke.scala_reflection.Big").asTerm
    // val b = Expr(Class.forName("co.blocke.scala_reflection.Big")).asTerm
    println("A: "+a)
    // println("B: "+b)
    // Apply(
    //     Select.unique(New(TypeTree.of[ClassRType]),"<init>"), 
    //     List( Expr("co.blocke.scala_reflection.Big").asTerm, Expr(Class.forName("co.blocke.scala_reflection.Big")).asTerm )
    // ).asExprOf[RType[T]]

    Apply(
        Select.unique(New(TypeTree.of[StringRType]),"<init>"), 
        Nil
    ).asExprOf[RType[T]]

    /*

No given instance of type quoted.ToExpr[co.blocke.scala_reflection.RType[T]] was found for parameter x$2 of method apply in object Expr.
I found:

    co.blocke.scala_reflection.Liftables.RTypeToExpr[T](ttype,
      quoted.ToExpr.ByteToExpr[T²])

But given instance ByteToExpr in object ToExpr does not match type quoted.ToExpr[T]

where:    T  is a type in method ofImpl
          T² is a type variable with constraint <: Byte
.bloop(172)
    */
    
  //------------------------
  //  <<  NON-MACRO ENTRY >>
  //------------------------
//   def of(clazz: Class[_]): RType[_] = RTypeOfNoPlugin().of(clazz)

  protected[scala_reflection] def foo[T]()(using quotes: Quotes): RType[T] =
    import quotes.reflect.*
    StringRType().asInstanceOf[RType[T]]


    /*
  protected[scala_reflection] def unwindType[T](quotes: Quotes)(aType: quotes.reflect.TypeRepr, resolveTypeSyms: Boolean = true): RType[T] =
    import quotes.reflect.*

    val className = aType.asInstanceOf[TypeRef] match {
      case AndType(_,_) => INTERSECTION_CLASS
      case OrType(_,_)  => UNION_CLASS
      case _: dotty.tools.dotc.core.Types.WildcardType => "scala.Any"
      case normal       => normal.classSymbol.get.fullName
    }
    StringRType().asInstanceOf[RType[T]]

    // this.synchronized {
    //   val tName = typeName(quotes)(aType)
    //   cache.getOrElse(tName, {
    //     if className == "scala.Any" then
    //       TastyReflection.reflectOnType(quotes)(aType, tName, resolveTypeSyms)
    //     else
    //       cache.put(tName, SelfRefRType(className))
    //       val reflectedRType = TastyReflection.reflectOnType(quotes)(aType, tName, resolveTypeSyms)
    //       cache.put(tName, reflectedRType)
    //       reflectedRType
    //   })
    // }
*/



error stacktrace:
scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)
	scala.meta.internal.pc.MetalsInteractive$.contextOfPath(MetalsInteractive.scala:52)
	scala.meta.internal.pc.MetalsInteractive$.contextOfPath(MetalsInteractive.scala:30)
	scala.meta.internal.pc.MetalsInteractive$.contextOfPath(MetalsInteractive.scala:30)
	scala.meta.internal.pc.completions.CompletionProvider.completions(CompletionProvider.scala:61)
	scala.meta.internal.pc.ScalaPresentationCompiler.complete$$anonfun$1(ScalaPresentationCompiler.scala:119)
