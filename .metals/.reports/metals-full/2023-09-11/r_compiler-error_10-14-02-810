java.lang.AssertionError: NoDenotation.owner
occurred in the presentation compiler.

action parameters:
offset: 2069
uri: file://<WORKSPACE>/src/main/scala/co.blocke.scala_reflection/exprs/Classes.scala
text:
package co.blocke.scala_reflection
package exprs

import scala.quoted.*
import rtypes.*

trait Thing[T]:
    val stuff: T
case class Foo[R](name: String, stuff:R) extends Thing[R]

object Classes:

  def makeExpr[T](crt: ClassRType[T])(using q:Quotes)(using Type[T]): Expr[RType[T]] = 
    import q.reflect.*
    crt match {
      case sc: ScalaClassRType[T] => 
        println("--1-- "+TypeRepr.of[ScalaClassRType].typeSymbol.primaryConstructor.toString)
        val clazz = TypeRepr.of[ScalaClassRType[T]].typeSymbol
        val classDef = clazz.asInstanceOf[ClassDef]
        println(clazz.caseFields)
        // println(TypeRepr.of[ScalaClassRType[T]].typeSymbol.primaryConstructor.signature)

        // val blah = TypeRepr.of[Foo[Int]].classSymbol.map( sym =>
        //   Apply(
        //     Select(New(TypeTree.of[Foo[Int]]), sym.primaryConstructor),
        //     List(Expr("Fred").asTerm, Expr(37).asTerm)
        //   )
        // )

        /*
        val zzz = Apply(
          Select.unique(New(TypeTree.of[ScalaClassRType[T]]), "<init>"),
          List(
            Expr(sc.name).asTerm,
            // Expr(sc.paramSymbols.asInstanceOf[List[String]]).asTerm,
            // {
            //   val xxx = sc._typeMembers.map( typeMemberRType => ExprMaster.makeExpr(typeMemberRType)(using quotes)(using typeMemberRType.toType(quotes)).asInstanceOf[Expr[TypeMemberRType[_]]] )
            //   val yyy = Expr.ofList(xxx)
            //   yyy.asTerm
            // }
        //     // Fields Expr here...
        //     Expr(sc._annotations).asTerm,
        //     Expr(sc.paths).asTerm,
        //     Expr(sc._mixins).asTerm,
            Expr(sc.isAppliedType).asTerm,
            Expr(sc.isValueClass).asTerm,
            Expr(sc.isCaseClass).asTerm
          )
        ).asExprOf[RType[T]]
        println("--2-- "+zzz)
        zzz
        */
        val name = Expr(sc.name)
        val applied = Expr(sc.isAppliedType)
        val valueClass = Expr(sc.isValueClass)
        val caseClass = Expr(sc.isCaseClass)
        '{ ScalaClassRType[T]($[name@@], $applied, $valueClass, $caseClass) }
    }

    /*
case class ScalaClassRType[R] protected[scala_reflection] (
    name:                   String,
    paramSymbols:           List[TypeSymbol],
    _typeMembers:           List[TypeMemberRType],
    _fields:                List[FieldInfo],
    _annotations:           Map[String, Map[String,String]],
    paths:                  Map[String, Map[String,List[Int]]],
    _mixins:                List[String],
    override val isAppliedType: Boolean,
    isValueClass:           Boolean,
    isCaseClass:            Boolean
) extends ClassRType[R]:
    */


error stacktrace:
dotty.tools.dotc.core.SymDenotations$NoDenotation$.owner(SymDenotations.scala:2576)
	scala.meta.internal.pc.SignatureHelpProvider$.isValid(SignatureHelpProvider.scala:83)
	scala.meta.internal.pc.SignatureHelpProvider$.notCurrentApply(SignatureHelpProvider.scala:96)
	scala.meta.internal.pc.SignatureHelpProvider$.$anonfun$1(SignatureHelpProvider.scala:48)
	scala.collection.StrictOptimizedLinearSeqOps.loop$3(LinearSeq.scala:280)
	scala.collection.StrictOptimizedLinearSeqOps.dropWhile(LinearSeq.scala:282)
	scala.collection.StrictOptimizedLinearSeqOps.dropWhile$(LinearSeq.scala:278)
	scala.collection.immutable.List.dropWhile(List.scala:79)
	scala.meta.internal.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:48)
	scala.meta.internal.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:371)
