java.lang.AssertionError: NoDenotation.owner
occurred in the presentation compiler.

action parameters:
offset: 2616
uri: file://<WORKSPACE>/src/main/scala/co.blocke.scala_reflection/RType.scala
text:
package co.blocke.scala_reflection

import scala.quoted.*

trait RType[R]:
  type T = R                // R is saved for accessibility during casting, ie myRType.asInstanceOf[fooRType.T]
  val name: String          // fully-qualified class name of this type
  val infoClass: Class[R]   // JVM class for this type
  def toType(quotes: Quotes): quoted.Type[R] = quotes.reflect.TypeRepr.typeConstructorOf(infoClass).asType.asInstanceOf[Type[R]]
  def show(
    tab: Int = 0,
    seenBefore: List[String] = Nil,
    suppressIndent: Boolean = false,
    modified: Boolean = false // modified is "special", ie. don't show index & sort for nonconstructor fields
  ): String
  override def toString(): String = show()

/** This RType mixin needed because j
 * ust because something is an AppliedType doesn't mean it has parameters.  
 *  For examlpe a case class could be an applied type (isAppliedType=true) or not.  A collection is always applied.
 */
trait AppliedRType[R]:
  self: RType[R] =>
  def isAppliedType: Boolean = true  // can be overridden to false, e.g. Scala class that isn't parameterized
  // Take a parameterized type's normal type 'T' and map it to the declared type 'X'
  def resolveTypeParams( paramMap: Map[TypeSymbol, RType[_]] ): RType[R]


// Poked this here for now.  Used for show()
final inline def tabs(t:Int) = "   "*t

case class StringRType() extends RType[String]{ val name = "String"; val infoClass = classOf[String] }


object RType:

//   // Allow Expr(RType[T])
//   given RTypeToExpr[T: Type: ToExpr]: ToExpr[RType[T]] with
//     def apply(rt: RType[T])(using Quotes): Expr[RType[T]] = rt match 
//       case r: RType[T] => Expr(r)

  //------------------------
  //  <<  MACRO ENTRY >>
  //------------------------
  inline def of[T]: RType[T] = ${ ofImpl[T]() }

  def ofImpl[T]()(implicit qctx: Quotes, ttype: scala.quoted.Type[T]): Expr[RType[T]] =
    import qctx.reflect.*
    Expr( unwindType[T](qctx)( TypeRepr.of[T]) )
    
  //------------------------
  //  <<  NON-MACRO ENTRY >>
  //------------------------
//   def of(clazz: Class[_]): RType[_] = RTypeOfNoPlugin().of(clazz)


  protected[scala_reflection] def unwindType[T](quotes: Quotes)(aType: quotes.reflect.TypeRepr, resolveTypeSyms: Boolean = true): RType[T] =
    import quotes.reflect.{_, given}

    val className = aType.asInstanceOf[TypeRef] match {
      case AndType(_,_) => INTERSECTION_CLASS
      case OrType(_,_)  => UNION_CLASS
      case _: dotty.tools.dotc.core.Types.WildcardType => "scala.Any"
      case normal       => normal.classSymbol.get.fullName
    }
    StringRType().asInstanceOf[RTyp[@@]]

    // this.synchronized {
    //   val tName = typeName(quotes)(aType)
    //   cache.getOrElse(tName, {
    //     if className == "scala.Any" then
    //       TastyReflection.reflectOnType(quotes)(aType, tName, resolveTypeSyms)
    //     else
    //       cache.put(tName, SelfRefRType(className))
    //       val reflectedRType = TastyReflection.reflectOnType(quotes)(aType, tName, resolveTypeSyms)
    //       cache.put(tName, reflectedRType)
    //       reflectedRType
    //   })
    // }




error stacktrace:
dotty.tools.dotc.core.SymDenotations$NoDenotation$.owner(SymDenotations.scala:2576)
	scala.meta.internal.pc.SignatureHelpProvider$.isValid(SignatureHelpProvider.scala:83)
	scala.meta.internal.pc.SignatureHelpProvider$.notCurrentApply(SignatureHelpProvider.scala:94)
	scala.meta.internal.pc.SignatureHelpProvider$.$anonfun$1(SignatureHelpProvider.scala:48)
	scala.collection.StrictOptimizedLinearSeqOps.loop$3(LinearSeq.scala:280)
	scala.collection.StrictOptimizedLinearSeqOps.dropWhile(LinearSeq.scala:282)
	scala.collection.StrictOptimizedLinearSeqOps.dropWhile$(LinearSeq.scala:278)
	scala.collection.immutable.List.dropWhile(List.scala:79)
	scala.meta.internal.pc.SignatureHelpProvider$.signatureHelp(SignatureHelpProvider.scala:48)
	scala.meta.internal.pc.ScalaPresentationCompiler.signatureHelp$$anonfun$1(ScalaPresentationCompiler.scala:371)
