This *NON-WORKING* code is claimed to instantiate a class having parameters of unknown types...

This post is hidden. It was deleted 12 months ago by the post author.
Given these two examples:

Deriving a type class with inlines that instantiates a case class
Deriving a type class with macros
How can they be combined to derive a type class using a macro that instantiates a case class?

I think I'm close but there seems to be a conflict over splicing vs quoting here:

// same code as referenced, but notice I've replaced with "Random" with "Eq" trait

def eqProduct[T](p: Mirror.ProductOf[T], instances: => List[Expr[Eq[_]]]): Expr[Eq[T]] =
  '{new Eq[T] { def generate: T = { p.fromProduct(toTuple(instances.map {k => ${k}.generate }, EmptyTuple))}}}

given derived[T: Type](using q: Quotes): Expr[Eq[T]] = {
  import quotes.reflect.*
  val ev: Expr[Mirror.Of[T]] = Expr.summon[Mirror.Of[T]].get
  ev match
    case '{$m: Mirror.ProductOf[T] {type MirroredElemTypes = elementTypes}} => {
      val elemInstances: List[Expr[Eq[_]]] = summonAll[elementTypes]
      '{eqProduct(${m}, elemInstances)} 
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Found:    quoted.Expr[Eq[T]]
// Required: Eq[T]
  
    }
  }
}
And if I do as it asks here's the conflict:

       '{${eqProduct(${m}, elemInstances)}}
                     ^^^^
  Splice ${...} outside quotes '{...} or inline method
The value in this approach is that it executes at compile-time (runtime performance boost) and that it allows arbitrary case class arguments. An alternative would be to construct the case class using e.g. Select(..), but I would need to handle variations in arguments, which type class derivation takes care of nicely.
